정적 파일(Static  Files)
- 사전적으로는 변화가 없는 파일
- Django / Flask 등의 웹프레임워크에서 정적파일이란 프레임워크의 소스코드를 제외한 나머지
	- 이미지, 동영상, CSS, JavaScript 파일 등
- 소스코드는 일반적으로 동적인 결과를 만들어내는 데 사용
- 정적 파일은 사용자에게 변형 없이 언제나 동일한 형태로 제공됨

템플릿에서 정적 팡리 사용
- 템플릿에서 정적파일을 불러올 때는
-- {% static '정적파일경로' %} 태그를 사용

유저가 업로드하는 정적 파일

정적 파일의 분류
- Django에서 정적 파일은 두가지로 나뉨
-- 소스코드에 포함되는 정적 파일
-- 유저가 업로드하는 정적 파일

- 이전에 정적파일을 넣어뒀던 디렉터리는 소스코드에 포함되는 정적파일을 두는 곳
-- 프로젝트의 일부분으로 취급됨

- 유저가 업로드하는 정적파일은 프로젝트에 포함되지 않음
-- 블로그라는 전체 프로젝트와는 별개로 블로그를 사용하는 사용자들이 업로드하는 글에 포함된 이미지와 같은 데이터

유저가 업로드하는 정적 파일 설정
- settings.py에서 소스코드에 포함되는 정적파일의 설정은 STATIC_ 로 시작
- 유저가 업로드하는 정적 파일과 관련된 설정은 MEDIA_로 시작

- MEDIA_URL
-- 유저가 업로드한 파일에 접근할 수 있도록 브라우저에 제공하는 경로의 접두어
--- 예시) 이미지의 이미지 주소를 검색한 경우
-- 소스코드에 포함되는 정적파일은 STATIC_URL 이라는 설정값을 사용하며, 기본값은 "/static/"

- MEDIA_ROOT
-- 실제로 유저가 업로드한 파일이 저장될 경로

이후 urls.py에 경로 추가해주어야함



```
from django.conf import settings
from django.conf.urls.static import static

urlpatterns += static(
    prefix=settings.MEDIA_URL,
    document_root=settings.MEDIA_ROOT,
)
```

settings.py 의 BASE_DIR = Path..... 밑에 작성

```
TEMPLATES_DIR = BASE_DIR / "templates"
```

TEMPLATES의 "DIRS" : 영역에 입력
[TEMPLATES_DIR]





동적 URL 경로
"post/<int:post_id>/"

int : 정수 형태의 값을 받도록 제한한다는 의미
post_id : <> 내의 영역이 post_id라는 이름을 가진다는 의미

<a>에 링크 연결 시 링크가 /로 시작하면 절대경로, /없이 시작하면 상대경로
-- 절대 경로는 메인페이지에서 시작
-- 상대경로는 현 페이지에서 시작?

사용자의 입력을 받는 Template
- HTML에서 사용자의 입력을 받는 요소
-- 입력에 대한 제목(이름) : <label>
-- 한줄짜리 텍스트 입력 : <input type="text">
-- 여러줄 텍스트 입력 : <textarea>
-- 제출 버튼 : <button>

- 사용자의 입력을 받는 요소는 form 태그로 감싸야 함 + 폼의 메소드 설정해주어야함
<form method="GET"> ... </form>
-- 메소드는 GET 혹은 POST를 주로 사용
--- GET : url에 담아서 데이터를 전송함. 주소창에 보이기 때문에 노출의 위험이 있음 / 긴 데이터는 곤란함
---- 주로 데이터 조회에 사용됨
--- POST : 미리 해줘야할 것이 많고 까다로움 = 귀찮음
---- 주로 데이터 생성/수정 등에 사용됨
-- div로 각각 입력할 항목들을 감싸고, 내부에 label로 해당 항목의 이름을 표시

POST 요청에 대한 Forbidden(403) 오류

- 요청은 받았으나 그 요청을 처리할 권한이 없기 때문에 서버에서 거부함
- CSRF 공격
-- CSRF 인증에 실패하여 요청이 중단됨
-- CSRF : Cross-Site Request Forgery ( 사이트간 요청 위조 ) 

-Django에서 처리하는 GET과 POST
-- 지금까지 CSRF 인증 오류가 발생하지 않은 이유는 Django가 데이터를 처리하는 방식이
    GET과 POST에 따라 다르기 때문
-- GET은 사이트의 특정 페이지에 접속하거나 검색을 하는 등의 읽기/조회 행동을 수행
-- POST는 사이트의 특정 데이터를 변경/작성 하는데 쓰임
-- 따라서 Django는 POST 요청에 대해서 GET 요청보다 더 높은 보안 수준을 적용함

- Django의 CSRF 공격 방어 기법
-- CSRF 공격 방어의 핵심은 로그인한 사용자가 의도하지 않은 POST 요청을 거부하는 것
	1. Django는 새로운 요청을 하는 브라우저마다 구분되는 값을 서버에 저장
	2. POST 요청을 하는 form이 브라우저별로 구분되는 값을 갖지 않는다면 요청 거부

-- 브라우저별로 구분되는 값은 서버에 저장되므로 브라우저를 이용하는 사람(이용자나 해커)
    그 값을 알 수 없음
	3. Template 파일에서 {% csrf_token %} 태그를 사용하면 이 영역은 브라우저별로
	   구분되는 값으로 치환됨

POST 데이터를 사용한 DB row 생성
- ORM을 사용해서 DB에 데이터를 생성할 때는 create 메서드를 사용
-- create_instance = 모델.objects.create(필드명=필드값)


